# -*- coding: utf-8 -*-
"""network_sniffer.py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12iBmx3vufvHdLCmqVTJD1ysETZUXMGpP
"""

#!/usr/bin/env python3
"""
Basic Network Sniffer
---------------------
This script captures network packets and displays their basic information.
Requires root/admin privileges to run.

Usage: sudo python3 network_sniffer.py [interface]
"""

import socket
import struct
import textwrap
import sys
import time
from datetime import datetime

# Check if the user has provided an interface
if len(sys.argv) == 2:
    INTERFACE = sys.argv[1]
else:
    INTERFACE = None  # Will use default interface

def main():
    """Main function to run the sniffer"""
    try:
        # Create a raw socket
        if INTERFACE:
            conn = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(3))
            conn.bind((INTERFACE, 0))
        else:
            conn = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(3))

        print(f"\n{'='*60}")
        print(f"Network Sniffer Started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Interface: {INTERFACE if INTERFACE else 'Default'}")
        print(f"{'='*60}\n")

        packet_count = 0

        while True:
            # Receive data
            raw_data, addr = conn.recvfrom(65536)
            packet_count += 1

            # Get timestamp
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]

            # Extract Ethernet frame
            dest_mac, src_mac, eth_proto, data = ethernet_frame(raw_data)
            print(f"\n[Packet #{packet_count} - {timestamp}]")
            print(f"Ethernet Frame:")
            print(f"  Destination MAC: {dest_mac}")
            print(f"  Source MAC: {src_mac}")
            print(f"  Protocol: {eth_proto}")

            # IPv4
            if eth_proto == 8:
                version, header_length, ttl, proto, src, target, data = ipv4_packet(data)
                print(f"IPv4 Packet:")
                print(f"  Version: {version}")
                print(f"  Header Length: {header_length} bytes")
                print(f"  TTL: {ttl}")
                print(f"  Protocol: {proto}")
                print(f"  Source IP: {src}")
                print(f"  Target IP: {target}")

                # ICMP
                if proto == 1:
                    icmp_type, code, checksum, data = icmp_packet(data)
                    print(f"ICMP Packet:")
                    print(f"  Type: {icmp_type}")
                    print(f"  Code: {code}")
                    print(f"  Checksum: {checksum}")
                    print(f"  Data:")
                    print(format_multi_line("    ", data))

                # TCP
                elif proto == 6:
                    src_port, dest_port, sequence, acknowledgment, flags, data = tcp_packet(data)
                    print(f"TCP Segment:")
                    print(f"  Source Port: {src_port}")
                    print(f"  Destination Port: {dest_port}")
                    print(f"  Sequence: {sequence}")
                    print(f"  Acknowledgment: {acknowledgment}")
                    print(f"  Flags: {flags}")

                    if len(data) > 0:
                        # HTTP
                        if src_port == 80 or dest_port == 80:
                            print("  HTTP Data:")
                            try:
                                http_data = data.decode('utf-8')
                                http_info = str(http_data).split('\n')
                                for line in http_info:
                                    print(f"    {line}")
                            except:
                                print(format_multi_line("    ", data))
                        else:
                            print("  TCP Data:")
                            print(format_multi_line("    ", data))

                # UDP
                elif proto == 17:
                    src_port, dest_port, length, data = udp_packet(data)
                    print(f"UDP Segment:")
                    print(f"  Source Port: {src_port}")
                    print(f"  Destination Port: {dest_port}")
                    print(f"  Length: {length}")
                    print(f"  Data:")
                    print(format_multi_line("    ", data))

                # Other
                else:
                    print(f"Other IPv4 Data:")
                    print(format_multi_line("  ", data))

            # Other Ethernet packets
            else:
                print("Other Ethernet Data:")
                print(format_multi_line("  ", data))

            # Print separator for readability
            print(f"{'-'*60}")

    except KeyboardInterrupt:
        print("\n\nSniffing stopped by user.")
        print(f"Total packets captured: {packet_count}")
        sys.exit(0)
    except PermissionError:
        print("\nError: This program requires root/administrator privileges.")
        print("Try running with 'sudo' on Linux/Mac or as Administrator on Windows.")
        sys.exit(1)
    except Exception as e:
        print(f"\nError: {e}")
        sys.exit(1)

# Unpack Ethernet frame
def ethernet_frame(data):
    """Unpack ethernet frame"""
    dest_mac, src_mac, proto = struct.unpack('! 6s 6s H', data[:14])
    return get_mac_addr(dest_mac), get_mac_addr(src_mac), socket.ntohs(proto), data[14:]

# Return properly formatted MAC address (AA:BB:CC:DD:EE:FF)
def get_mac_addr(bytes_addr):
    """Format MAC address"""
    bytes_str = map('{:02x}'.format, bytes_addr)
    return ':'.join(bytes_str).upper()

# Unpack IPv4 packet
def ipv4_packet(data):
    """Unpack IPv4 packet"""
    version_header_length = data[0]
    version = version_header_length >> 4
    header_length = (version_header_length & 15) * 4
    ttl, proto, src, target = struct.unpack('! 8x B B 2x 4s 4s', data[:20])
    return version, header_length, ttl, proto, ipv4(src), ipv4(target), data[header_length:]

# Returns properly formatted IPv4 address
def ipv4(addr):
    """Format IPv4 address"""
    return '.'.join(map(str, addr))

# Unpack ICMP packet
def icmp_packet(data):
    """Unpack ICMP packet"""
    icmp_type, code, checksum = struct.unpack('! B B H', data[:4])
    return icmp_type, code, checksum, data[4:]

# Unpack TCP segment
def tcp_packet(data):
    """Unpack TCP segment"""
    (src_port, dest_port, sequence, acknowledgment, offset_reserved_flags) = struct.unpack('! H H L L H', data[:14])
    offset = (offset_reserved_flags >> 12) * 4
    flags = {
        'FIN': (offset_reserved_flags & 1) != 0,
        'SYN': (offset_reserved_flags & 2) != 0,
        'RST': (offset_reserved_flags & 4) != 0,
        'PSH': (offset_reserved_flags & 8) != 0,
        'ACK': (offset_reserved_flags & 16) != 0,
        'URG': (offset_reserved_flags & 32) != 0
    }
    flag_str = ' '.join([flag for flag, val in flags.items() if val])
    return src_port, dest_port, sequence, acknowledgment, flag_str, data[offset:]

# Unpack UDP segment
def udp_packet(data):
    """Unpack UDP segment"""
    src_port, dest_port, size = struct.unpack('! H H H 2x', data[:8])
    return src_port, dest_port, size, data[8:]

# Format multi-line data
def format_multi_line(prefix, string, size=80):
    """Format multi-line output with prefix"""
    if isinstance(string, bytes):
        # Try to decode if it's text data
        try:
            string = string.decode('utf-8')
        except UnicodeDecodeError:
            # If it's not text data, show as hex dump
            hex_dump = ' '.join(f'{byte:02x}' for byte in string)
            string_dump = ''.join(chr(byte) if 32 <= byte <= 126 else '.' for byte in string)

            result = []
            for i in range(0, len(hex_dump), size):
                hex_line = hex_dump[i:i+size]
                result.append(f"{prefix}{hex_line}")

            # Add ASCII representation
            chunk_size = size // 3  # Each byte takes 3 chars in hex_dump (2 hex + 1 space)
            for i in range(0, len(string_dump), chunk_size):
                result.append(f"{prefix}ASCII: {string_dump[i:i+chunk_size]}")

            return '\n'.join(result)

    # For text data or already decoded
    size = size - len(prefix)
    if isinstance(string, str):
        string = string.replace('\n', '\n' + prefix)
        return '\n'.join(prefix + line for line in textwrap.wrap(string, size))
    else:
        return prefix + str(string)

if __name__ == "__main__":
    main()